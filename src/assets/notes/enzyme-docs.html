<!DOCTYPE html>
<html>
    <head>
        <title>Enzyme Testing Documentation</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="created" content="2018-03-05T12:28:08-0800"/>
        <meta name="modified" content="2018-04-03T17:21:43-0700"/>
        <meta name="tags" content=""/>
        <meta name="last device" content="Gina’s MacBook Pro"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1>Enzyme Testing Documentation</h1>
<h3>What</h3>
<p>At Glidr we use Enzyme to test our front end framework. For our assertion library we use chai-enzyme (mocha/chai). This article will dive deeper into what that actually means, and also show you some example code along the way. After reading this you should be able to understand and implement unit tests for our front end application.</p>
<h3>Quick Guide</h3>
<p><b>Enzyme: Creating a wrapper with Shallow, Mount and Render.</b></p>
<p>Before you can begin to make assertions and test a component, you have to simulate a rendition of it.</p>
<ul><li>	Rendering with <a href="http://airbnb.io/enzyme/docs/api/shallow.html">shallow</a>: helpful for testing your component as a unit, shallow ensures that you aren’t making assertions on child components.
</li><li>	Rendering with <a href="http://airbnb.io/enzyme/docs/api/mount.html">mount</a>: ideal for testing component life cycles and DOM API.
</li><li>	Render with <a href="http://airbnb.io/enzyme/docs/api/render.html">render</a>: renders static HTML.
</li></ul>
<pre><code class='code-multiline'>describe(<span class="sf_code_syntax_string">'Foo'</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">'will render with shallow'</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
  });
  it(<span class="sf_code_syntax_string">'will render with mount'</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> mount(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
  });
  it(<span class="sf_code_syntax_string">'will render with render'</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> render(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
  });
});
</code></pre>A standard naming convention for component renditions in the enzyme docs is <code class='code-inline'>wrapper</code>.
As far as the API goes,  shallow and mount are especially similar, but I’ll point out differences as they come up. 
Here are some of the enzyme methods that will help you manipulate and traverse your rendered components.

<b>Find</b>. This method is really useful when you need to single out labels, forms and just for those times when you need to get div specific. This is my go to method for traversing. 
<pre><code class='code-multiline'>describe(<span class="sf_code_syntax_string">"Foo"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">"will have one label"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
    expect(wrapper.find(<span class="sf_code_syntax_string">"label"</span>)).to.have.length(<span class="sf_code_syntax_number">1</span>)
  });
});</code></pre>
<p><br></p>
<p><b>Instance</b>. When you render your component enzyme gives you a toolkit for manipulating that simulated instance of your component. So if  <Foo /> had a method called <code class='code-inline'>handleFocus</code>, we might want to evoke that method for testing purposes. You would do that like this:</p>
<pre><code class='code-multiline'>describe(<span class="sf_code_syntax_string">'Foo'</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">"has a method called handleFocus"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
    wrapper.instance().handleFocus(); <span class="sf_code_syntax_comment">// calls handleFocus
</span>  });
});</code></pre>
<p><br></p>
<p><b>SetProps & SetState</b>. If you need to, you can also set props, and manipulate the state of your component within a test.</p>
<pre><code class='code-multiline'>describe(<span class="sf_code_syntax_string">"Foo"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">"can take props & state through Enzyme tools!"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
    wrapper.setProps({ <span class="sf_code_syntax_character">foo</span>: <span class="sf_code_syntax_string">"gbenavid"</span> });
    <span class="sf_code_syntax_comment">// set props will rerender &lt; Foo /&gt; and will hit the componentWillReceiveProps lifecycle method. **More about this later
</span>	  wrapper.setState({ <span class="sf_code_syntax_character">bar</span>: <span class="sf_code_syntax_string">"K1TT3NzRUL3¡!¡!"</span> });
    expect(wrapper.state(<span class="sf_code_syntax_string">'bar'</span>)).to.equal(<span class="sf_code_syntax_string">"K1TT3NzRUL3¡!¡!"</span>);
  });
});
</code></pre>If you would like to test <code class='code-inline'>componentDidUpdate</code> establish your wrapper like so:
<code class='code-inline'>const wrapper = shallow(&lt;MyComponent /&gt;, { lifecycleExperimental: true });</code>

<b>Simulate</b>. This one is really cool. Enzyme has a way for you to simulate events. I’m mounting here, but you can also do a shallow render. This is helpful for hitting those methods that only execute on some event, I.e submit. /Occasionally you must mount if you’re testing DOM APIs and/or refs/.
<pre><code class='code-multiline'>describe(<span class="sf_code_syntax_string">"Foo"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">"textarea hits method handleBlur"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    const wrapper <span class="sf_code_syntax_keyword">=</span> mount(<span class="sf_code_syntax_keyword">&lt;</span>Foo/<span class="sf_code_syntax_keyword">&gt;</span>);
    wrapper.find(<span class="sf_code_syntax_string">"textarea"</span>).simulate(<span class="sf_code_syntax_string">"blur"</span>);
    <span class="sf_code_syntax_comment">// simulate also supports 'change', 'focus', 'submit' among others.
</span>  });
});</code></pre>
<p><br></p>
<p>Simulate also takes an optional argument as an event.</p>
<p>How to pass object with event(s)</p>
<pre><code class='code-multiline'>let e = {target : { value: null }}
 wrapper.find("textarea").simulate("blur", e)</code></pre>
<p><br></p>
<p><b>Testing refs & simulating clicks.</b></p>
<pre><code class='code-multiline'>// In your jsx/ React component file
&lt;<span class="sf_code_syntax_character">textarea</span>
  <span class="sf_code_syntax_keyword">ref</span>=<span class="sf_code_syntax_string">"input"</span>
  <span class="sf_code_syntax_keyword">className</span>=<span class="sf_code_syntax_string">"reusable-input"</span>
  <span class="sf_code_syntax_keyword">style</span>=<span class="sf_code_syntax_string">{this.state.inputStyle}</span>
  <span class="sf_code_syntax_keyword">value</span>=<span class="sf_code_syntax_string">{this.props.value}</span>
  <span class="sf_code_syntax_keyword">onChange</span>=<span class="sf_code_syntax_string">{this.handleChange}</span>
  <span class="sf_code_syntax_keyword">onBlur</span>=<span class="sf_code_syntax_string">{this.handleBlur}</span>
  <span class="sf_code_syntax_keyword">onFocus</span>=<span class="sf_code_syntax_string">{this.handleFocus}</span>
  <span class="sf_code_syntax_keyword">onKeyDown</span>=<span class="sf_code_syntax_string">{this.handleKeyDown}</span>
/&gt;</code></pre>
<p><br></p>
<p>I could test any of the above functions like this with chai simulations.</p>
<pre><code class='code-multiline'>    <span class="sf_code_syntax_project">let</span> spy <span class="sf_code_syntax_keyword">=</span> chai.spy.on(<span class="sf_code_syntax_keyword">Foo</span>.<span class="sf_code_syntax_keyword">prototype</span>, <span class="sf_code_syntax_string">"someFunction"</span>);
    const wrapper <span class="sf_code_syntax_keyword">=</span> mount(<span class="sf_code_syntax_keyword">&lt;</span>ReusableTextArea {...props}/<span class="sf_code_syntax_keyword">&gt;</span>); 
    <span class="sf_code_syntax_comment">// if you have a function that hits a DOM API then you need to mount
</span>    wrapper.find(<span class="sf_code_syntax_string">"textarea"</span>).simulate(<span class="sf_code_syntax_string">"blur"</span>);
    expect(spy).to.have.been.called.once();</code></pre>
<p><br></p>
<h2>Making assertions and actual testing!</h2>
<ul><li><b>Chai.js</b> (assertion library for enzyme)
</li></ul>
<p>Next you’ll learn how to make assertions, and manipulate your rendered components. So far we’ve only traversed and rendered jsx. Now we’ll brush over some basic functionality provided by Chai, and a plugin called chai-spies. I’ll just brush over my personal favorite methods, and then hopefully you’ll have a better foundation before you dive into the <a href="https://github.com/chaijs/chai-spies">docs</a>. Also chai-spies has a handful of chainable getters that I won’t directly cover, but you can do a quick reference of all of the available ones in the docs.</p>
<p>The spy interface looks like this: <code class='code-inline'>chai.spy( &lt;Obj&gt;, &lt; [method] &gt; )</code>. I’ve used it in the above examples, but here is where I’ll explain how to implement it. </p>
<p>Spy on method in component <code class='code-inline'>Foo</code></p>
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// to use this pluggin add this to the top of your testing file
</span>const chai <span class="sf_code_syntax_keyword">=</span> require(<span class="sf_code_syntax_string">"chai"</span>), spies <span class="sf_code_syntax_keyword">=</span> require(<span class="sf_code_syntax_string">"chai-spies"</span>);
chai.use(spies);
import Foo from <span class="sf_code_syntax_string">"./&lt;path to component&gt;/Foo.jsx"</span>;
describe(<span class="sf_code_syntax_string">"Foo"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  it(<span class="sf_code_syntax_string">"a call to handleBlankSpace will not error"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
    <span class="sf_code_syntax_project">let</span> spy <span class="sf_code_syntax_keyword">=</span> chai.spy(<span class="sf_code_syntax_keyword">Foo</span>.<span class="sf_code_syntax_keyword">prototype</span>, <span class="sf_code_syntax_string">"componentWillRecieveProps"</span>); <span class="sf_code_syntax_keyword">&lt;</span>DECLARE SPY<span class="sf_code_syntax_keyword">&gt;</span>
	  const wrapper <span class="sf_code_syntax_keyword">=</span> mount(<span class="sf_code_syntax_keyword">&lt;</span>Foo/<span class="sf_code_syntax_keyword">&gt;</span>); <span class="sf_code_syntax_keyword">&lt;</span>DECLARE WRAPPER<span class="sf_code_syntax_keyword">&gt;</span>
    wrapper.setProps({<span class="sf_code_syntax_character">bar</span>: <span class="sf_code_syntax_string">"baz"</span>}); <span class="sf_code_syntax_keyword">&lt;</span>MANIPULATE YOUR COMPONENT THERE<span class="sf_code_syntax_keyword">&gt;</span>
    expect(spy).to.have.been.called.once(); <span class="sf_code_syntax_keyword">&lt;</span>ASSERTION<span class="sf_code_syntax_keyword">&gt;</span>
  });
});</code></pre>
<p><br></p>
<p>Making assertions based on props and state.</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// in jsx file
</span><span class="sf_code_syntax_keyword">this</span>.state<span class="sf_code_syntax_keyword">=</span> {
  <span class="sf_code_syntax_character">bar</span>: <span class="sf_code_syntax_string">"red"</span>
}
<span class="sf_code_syntax_project">let</span> changeState <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_project">function</span> () {
  <span class="sf_code_syntax_keyword">this</span>.setState({<span class="sf_code_syntax_character">bar</span>: <span class="sf_code_syntax_string">"blue"</span>});
}
<span class="sf_code_syntax_comment">// in testing file:
</span>it(<span class="sf_code_syntax_string">"handleChange will assert new state"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo {...props}/<span class="sf_code_syntax_keyword">&gt;</span>);
  <span class="sf_code_syntax_comment">// pass props to components using the spread operator.
</span>  wrapper.instance.changeState();
  expect(wrapper.state(<span class="sf_code_syntax_string">"bar"</span>)).to.equal(<span class="sf_code_syntax_string">"blue"</span>);
});</code></pre>
<p><br></p>
<p>Testing inner functions. </p>
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// in your jsx file:
</span><span class="sf_code_syntax_project">let</span> parentFunction <span class="sf_code_syntax_project">function</span>() {
  <span class="sf_code_syntax_keyword">this</span>.childFunction();
}
<span class="sf_code_syntax_comment">// in your test file
</span>it(<span class="sf_code_syntax_string">"an example of testing inner functions"</span>, () <span class="sf_code_syntax_keyword">=&gt;</span> {
  const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo {...props}/<span class="sf_code_syntax_keyword">&gt;</span>);
  <span class="sf_code_syntax_project">let</span> spy <span class="sf_code_syntax_keyword">=</span> chai.spy.on(wrapper, <span class="sf_code_syntax_string">"childFunction"</span>);
  wrapper.instance().parentFunction();
  expect(spy).to.have.been.called.once();
})</code></pre>
<p><br></p>
<br>
<p> <b>SetTimeouts</b> (and other mocha rich features): Mocha is responsible for all of the asynchronous testing functionality. There’s <a href="https://mochajs.org/#timeouts">a ton of cool functionality</a> that can be done with mocha, but to start <i>setTimeout</i> is one that I found particularly helpful. </p>
<pre><code class='code-multiline'>it(<span class="sf_code_syntax_string">"some test that uses setTimeout"</span>, (done) <span class="sf_code_syntax_keyword">=&gt;</span> { <span class="sf_code_syntax_comment">// set the scope of done by passing it as an arg to your it block
</span>  const wrapper <span class="sf_code_syntax_keyword">=</span> shallow(<span class="sf_code_syntax_keyword">&lt;</span>Foo /<span class="sf_code_syntax_keyword">&gt;</span>);
  <span class="sf_code_syntax_project">let</span> spy <span class="sf_code_syntax_keyword">=</span> chai.spy.on(wrapper, <span class="sf_code_syntax_string">"childFunction"</span>);
	wrapper.instance().parentFunction();
  <span class="sf_code_syntax_keyword">setTimeout</span>(() <span class="sf_code_syntax_keyword">=&gt;</span> {
    expect(wrapper.state(<span class="sf_code_syntax_string">"foo"</span>)).to.equal(<span class="sf_code_syntax_string">"lorem"</span>);
    done(); <span class="sf_code_syntax_comment">// if you don't call done, then your test will error saying youve exceeded the time limit 
</span>  }, <span class="sf_code_syntax_number">100</span>); <span class="sf_code_syntax_comment">// youll need to find this number in the setTimeout function youre testing. It controlls how long your test will wait
</span>});</code></pre>
<p><br></p>
<ul><li><b>Gotchas</b>:
</li></ul>
<p>Make sure that you're test is passing when you expect it to pass and breaking when you expect it to break. </p>
<p>Here are a few gotchas that I’ve found.</p>
<pre><code class='code-multiline'>to.be.called.once <span class="sf_code_syntax_comment">// does not have to be evoked for stylistic flare
</span>to.be.called() <span class="sf_code_syntax_comment">// MUST be evoked otherwise the test will ALWAYS pass.</span></code></pre>
<p><br></p>
<hr>
<h3>Resources</h3>
<p><a href="http://airbnb.io/enzyme/docs/api/">Enzyme API Docs</a></p>
<p><a href="http://airbnb.io/projects/enzyme/">Enzyme | Airbnb Engineering</a></p>
<br>
<h3>Have a question/ comment/ concern about these docs? </h3>
<p><a href="https://github.com/gbenavid/gbenavid.github.io/issues/new">Let me Know via GitHub <3</a></p>
        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol " + ol_start + ";");

    }

})();
        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:.31429em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol li:before{content:counter(ol) ".";counter-increment:ol;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_syntax_string{color:#D33905}.sf_code_syntax_comment{color:#838383}.sf_code_syntax_documentation_comment{color:#128901}.sf_code_syntax_number{color:#0E73A2}.sf_code_syntax_project{color:#5B2599}.sf_code_syntax_keyword{color:#0E73A2}.sf_code_syntax_character{color:#1B00CE}.sf_code_syntax_preprocessor{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.35em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.45em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked .todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline;background:white;border:solid 1px #dedede;padding:0.2em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline-block;padding:0px 4px;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
